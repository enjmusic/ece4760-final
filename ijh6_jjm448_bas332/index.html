<!DOCTYPE html>
<html>

<head>
	<title>Final Project Report - Wavetable Synthesizer</title>
	<link rel="stylesheet" href="style/default_style.css">
	<link rel="stylesheet" href="style/style.css">
	<link rel="icon" href="images/favicon.ico">
	<meta charset="UTF-8">
	<meta name="description" content="ECE 4760 Project by Ian Hoffman (ijh6), Joval Mathew (jjm448), and Balazs Szegletes (bas332)">
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet">
</head>

<body>
	<!-- TOP OF PAGE -->
	<div id="top"></div>

	<!-- PAGE HEADER -->
	<h1 id="title">
		ECE 4760 Final Project Report <br>
		Programmable Sequenced Wavetable Synthesizer

		<!-- IMAGES IN HEADER -->
		<img src="images/header_img_1.png" alt="waveform1" class="top-img" style="left: 7.5px;">
		<img src="images/header_img_2.png" alt="waveform2" class="top-img" style="right: 7.5px;">
	</h1>

	<br>

	<!-- AUTHORS -->
	<h2 class="section-header">Authors</h2>
	<br>
	<ul id="authors">
		<li>
			Ian Hoffman (ijh6)
		</li>
		<li>
			Joval Mathew (jjm448)
		</li>
		<li>
			Balazs Szegletes (bas332)
		</li>
	</ul>

	<br>

	<!-- PAGE TABLE OF CONTENTS -->
	<h2 class="section-header">Table of Contents</h2>
	<br>
	<ul id="table-of-contents">
		<li>
			<a href="#introduction">Introduction</a>
		</li>
		<li>
			<a href="#high-level">High-Level Design</a>
		</li>
		<li>
			<a href="#hardware-software-design">Hardware/Software Design</a>
		</li>
		<li>
			<a href="#results">Results</a>
		</li>
		<li>
			<a href="#conclusion">Conclusion</a>
		</li>
		<li>
			<a href="#appendix-a">Appendix A</a>
		</li>
		<li>
			<a href="#commented-program">Commented Program Files</a>
		</li>
		<li>
			<a href="#schematics">Schematics</a>
		</li>
		<li>
			<a href="#cost-details">Cost Details</a>
		</li>
		<li>
			<a href="#member-roles">Member Roles</a>
		</li>
		<li class="list-last">
			<a href="#references">References</a>
		</li>
	</ul>

	<br>
	<br>
	<br>

	<!-- PAGE SECTIONS -->
	<h2 class="section-header" id="introduction">Introduction</h2>
	<div class="report-section">
		<h3 class="subsection-header"> Soundbite </h3>
		<div class="subsection-content">
			For our final project, we created a wavetable synthesizer capable of playing back short user-programmable
			sequences with a large range of timbres.
		</div>
		<br>

		<h3 class="subsection-header"> Summary </h3>
		<div class="subsection-content">
			We decided to create a fun, easy-to-use wavetable synthesizer with just enough parameters 
			to offer a large sonic range, while limiting the controls to keep the user interface clean and 
			as unconfusing as possible. This goal was driven by the desire to make a useful product relevant 
			to the current digital synthesizer market, an area in which wavetable synthesis is very popular. 
			This method of synthesis allows for arbitrary waveforms, as well as blends of multiple waveforms, 
			allowing for a number of tones only limited by the storage capacity of the device. 
		</div>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- HIGH-LEVEL DESIGN -->
	<h2 class="section-header" id="high-level">High-Level Design</h2>
	<div class="report-section">
		<h3 class="subsection-header"> Rationale </h3>
		<div class="subsection-content">

			The motivation behind this final project was to design and build a cheap and 
			easy-to-use sequenced wavetable synthesizer, primarily useful for basslines. 
			It was mainly inspired by classic digital/digitally-assisted synthesizers like 
			the 

			<a class="external" href="https://en.wikipedia.org/wiki/PPG_Wave">PPG Wave</a>, 

			<a class="external" href="http://www.vintagesynth.com/waldorf/microwave.php">Waldorf Microwave</a>,

			and 

			<a class="external" href="https://en.wikipedia.org/wiki/Roland_TB-303">Roland TB303</a>. 
			
			However, we wanted to make 
			a wavetable synthesizer with simple, user-friendly controls, while still allowing 
			the user to produce a wide range of sounds at a high audio quality. Wavetable 
			synthesis, which is the method of repeating (and sometimes fading between) waveforms
			in tables in memory, is a very easy way to produce many timbres in software 
			inexpensively, so it was an obvious choice for our synthesis engine.

		</div>
		<br>

		<h3 class="subsection-header"> Background Math </h3>
		<div class="subsection-content">
			background math text... (discuss phase accum calculation used in .rb files)
		</div>
		<br>

		<h3 class="subsection-header"> Logical Structure </h3>
		<div class="subsection-content">
			logical structure text...
		</div>
		<br>

		<h3 class="subsection-header"> Hardware/Software Tradeoffs </h3>
		<div class="subsection-content">

			The main hardware/software tradeoffs we dealt with revolved around amplitude 
			control and the associated amplitude envelope generation for our synthesizer 
			voice. Our amplitude control was implemented in software, using the DDS ISR 
			and some shift operations/multiplication to scale the output sample by the 
			amplitude envelope. This envelope was also generated in the ISR, with parameters 
			calculated from values read in our knob value reading thread. 

			<br><br>

			Generating the amplitude envelope using a hardware envelope generator circuit 
			would have been more expensive and increased circuit complexity, but users would 
			be able to have more control over the envelope shape. We had to compromise on 
			envelope shape control for simplicity of user experience, as well as limited 
			ADC capabilities. To scale the amplitude of the output audio in hardware, we 
			would need to construct a VCA (voltage-controlled amplifier) circuit, using 
			transistors, and OTA, or a dedicated VCA integrated circuit. This would have 
			also added to costs and circuit complexity.

			<br><br>

			A small extra step would also need to be taken to allow for hardware generation 
			of the amplitude envelope - since it would no longer be triggered in the ISR, 
			it would not have access to the knowledge of when a step change in the sequence 
			occurred. So, another digital output pin would have to be configured, and in the 
			ISR a trigger would have to be sent out on this digital pin to trigger the 
			amplitude envelope on active steps.

			<br><br>

			We were able to fit the amplitude scaling and envelope generation into the DDS 
			ISR in software, reducing the customization of envelope shaping, but also greatly 
			reducing the cost and circuit complexity of the final product.

		</div>
		<br>

		<h3 class="subsection-header"> Use of Existing Standards </h3>
		<div class="subsection-content">

			We did not use any common standards for this project. One possible standard we
			could have used, has this been a keyboard-controlled synthesizer, would be MIDI.
			However, since we generate and modify our 16-step sequence internally, it does
			not make sense to use the MIDI standard to represent note onsets, offsets, and
			pitches.

		</div>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- HARDWARE/SOFTWARE DESIGN -->
	<h2 class="section-header" id="hardware-software-design">Hardware/Software Design</h2>
	<div class="report-section">
		<h3 class="subsection-header"> Software Details </h3>
		<div class="subsection-content">

			<h4 class="subsubsection-header"> Synthesis/Sequencer Parameters </h4>

			In our software, there are dozens of variables that refer to different synthesis
			parameters. Two char arrays, step_notes and steps_on, represent the note and
			activity (rest or note) of each step in the 16-step sequence. In step_notes, a
			note is represented by an index, 0-48, into a table of phase accumulators, 
			calculated using freq_accum_calcs.rb, which can be found in the 
			<a class="external" href="#commented-program">Commented Program Files</a> section.

			<br><br>

			The old_step_select, step_select, note_select, old_step, and curr_step variables
			are used for sequence editing and playback, both to supply the TFT-update thread
			with information it needs to draw the sequence state, and to facilitate reading
			and writing data to/from the two sequence arrays mentioned above. The seq_active
			variable is used in the DDS ISR to determine whether or not to add the sequence
			advancing phase accumulator to the step_accum counter. The phase accumulators for
			each tempo were calculated using tempo_accum_calcs.rb, which can be found in the
			<a class="external" href="#commented-program">Commented Program Files</a> section.

			<br><br>

			There are many flags, accumulators, and values that go into making the amplitude
			and shape blend envelopes work. The amp_env, shape_env, and shape_amt variables
			hold the values for the modal envelopes, and the attenuation amount for the shape
			envelope respectively, all set directly from the ADC reading thread. The rising
			variables are used as flags in the DDS ISR to determine whether to add or subtract
			the accumulator. The rise_acc and fall_acc variables for both envelopes are set 
			using envelope rise/fall phase accumulators calculated in env_bound_accum_calcs.rb, 
			which can be found in the <a class="external" href="#commented-program">
			Commented Program Files</a> section. These accumulators are 
			blended across the turn of the modal envelope knobs, allowing fades through 
			different envelope lengths and shapes.

			<br><br> 

			Both envelopes are AD envelopes. At the left side of the knob, the envelope has
			a short attack and long decay. As the knob moves towards the center of its turn, 
			the decay becomes longer until a certain keyframe, at which point the attack
			starts lengthening, making the envelope's shape more triangular. After this 
			keyframe, the attack continues to become longer as the decay shortens, eventually
			resulting in shapes inverse to those on the left side of the knob, in which the
			attack is long but the decay is very short. The specific time values of each
			envelope keyframe are listed in comments in env_bound_accum_calcs.rb.

			<br><br>
			<h4 class="subsubsection-header"> DDS ISR </h4> 

			Our DDS ISR (Direct Digital Synthesis Interrupt Service Routine) accomplishes
			all the tasks it needs to very expediently. This is necessary because of the speed
			at which it is run: 100kHz. In these 400 cycles, with cycles to spare for other
			threads like the button, multiplexer, or TFT threads, the procedures executed
			are as follows:

			<br><br>
			<ul class="insection-list">
				<li>
					Scaling the shape envelope value by its attenuation, then adding it
					to the wave blend offset and clipping the result if it is too high
				</li>
				<li>
					Getting the two waves within the current wavetable to use in the
					WAVE_BLEND macro, using bitwise operations on the overall blend
					value
				</li>
				<li>
					Using the WAVE_BLEND macro to blend between the two waves, using
					the subtable blend value, the above-calculated table offsets, and
					the DDS phase accumulator
				</li>
				<li>
					Scaling the calculated sample by the value of the amplitude envelope, 
					then writing this sample to the DAC
				</li>
				<li>
					Updating the DDS phase accumulator and sequence position
				</li>
				<li>
					Updating the envelopes' values, taking into account each envelope's 
					rising flags and rise/fall phase accumulators, clipping results if
					necessary
				</li>
				<li>
					Setting step update flag for TFT thread if the sequencer step changed,
					so that the UI can reflect this change
				</li>
			</ul>

			<br>

			Using integer operations instead of fix16 operations, as well as choosing scaling
			values to allow division using variable right shift, allowed the DDS ISR to function
			properly in the small window of time it was allowed.

			<br><br>
			<h4 class="subsubsection-header"> TFT/User Interface </h4> 

			The intitial sequence state, as well as the general UI format, is drawn to the TFT
			using the helper function initTFT(), which is called from main. After this point,
			once threads have been scheduled and the program is fully started, the TFT is 
			updated 20 times per second, using a dedicated TFT update thread.

			<br><br>

			In the TFT update thread, flags set in the ISR and the other threads allow for
			updating the sequence state only when necessary. Only steps which have changed
			will be redrawn, and the red/green selector boxes for selected and active
			sequence steps will only be moved if their positions have been changed. Copies
			of all flags which are set in the ISR, such as the old and current step, are 
			made in the TFT update thread to ensure that their values don't change in between
			dependent drawing steps. The tempo, note-to-write, and table index are all 
			rewritten each time the TFT update thread's loop executes.

			<br><br>
			<h4 class="subsubsection-header"> Multiplexing Input </h4>

			The multiplexing of input through the 1 on-board ADC was done in a dedicated
			thread. In this thread, all 7 potentiometer values were read into their respective
			variables, with any data manipulations needed done as well (such as converting
			raw envelope positions into rise/fall accumulators). The 3 control bits for the
			multiplexer had to be switched before each read, after which a couple short waits
			(implemented using an empty while loop) was required before reading the ADC value.
			Overall, the procedure for each of the 7 reads was largely identical and was as
			follows:

			<br><br>
			<ul class="insection-list">
				<li>
					Set BIT_7, BIT_8, and BIT_9 on IOPORT_B to represent the index of the 
					multiplexer input in binary, from 0-7
				</li>
				<li>
					Wait for approximately 80 cycles
				</li>
				<li>
					Acquire the ADC (would not have been needed if auto-capture were on)
					using the AcquireADC10() function
				</li>
				<li>
					Wait for approximately 40 more cycles
				</li>
				<li>
					Set old value variables if needed, then read the new value using
					ReadADC10(0) and process the read value quickly
				</li>
			</ul>

			<br><br>
			<h4 class="subsubsection-header"> Button Processing </h4>

			The four buttons were processed using a thread which was run at
			approximately 10Hz. Because of the slow rate of button value capture,
			we deemed it unnecessary to debounce the buttons. The button thread was,
			as a result, rather simple. For each button, the previous value of the
			button was stored. If the newly-read value of the button from its digital
			input pin was different from the previous value, and this new value signified
			that the button was being pressed, the data the button controlled would
			be modified. When writing a new note value, or changing a step's rest
			state, the button thread would set some flags for the TFT thread to notify
			it about which step had been changed, allowing the TFT thread to do less
			work.

			<br><br>
			<h4 class="subsubsection-header"> Creating Wavetables </h4>

			All of our wavetables were initially designed custom in the VST Plugin 
			<a class="external" href="https://www.xferrecords.com/products/serum/">Serum</a>
			by Xfer Records, an advanced wavetable synthesizer with a built-in 
			wavetable creation tool. After these wavetables were created, the .wav files
			that represented them were converted to 32-bit signed .raw files using
			the free audio software, Audacity. The wavetables in Serum initially
			were represented as 32-bit float, with 512 samples per table. Using 
			8 waves per table, as we did, this meant that each wavetable had 4096
			32-bit samples, resulting in around 16KB per table.

			<br><br>

			After being converted into .raw format, each wavetable was converted
			into a C header file using a custom command-line script, convert.cpp,
			which can be found in the <a class="external" href="#commented-program">
			Commented Program Files</a> section. It allows the user to specify the
			name of the array in which the samples will be placed. We used these
			array names later in our int *tables array, which contained the four
			wavetables. The header files containing the wavetables were rather large,
			and as such have not been included in this report.

			<br><br>
			<h4 class="subsubsection-header"> Use of unsigned ints instead of fix16 </h4>

			We decided to use unsigned integers to hold all of our synthesis parameters,
			even ones that would have to be scaled by others. We made this choice mainly
			to achive speed in the DDS ISR, for better audio fidelity via a higher sample
			rate and more time for threads to perform their respective tasks. The barrel
			shift allowed by the PIC32's ALU made division before scaling very fast, which
			came in handy for crossfading between waveshapes, fading between envelope 
			keyframes, scaling shape modulation, and scaling the DDS sample by the 
			amplitude envelope.

			<br><br>
			<h4 class="subsubsection-header"> Configuring the DAC and ADC </h4>

			The DAC and ADC were configured using code modified from examples on the
			course website. We put most of our configuration code in two functions,
			initADC and initDAC, which were both called from the main procedure of our
			program. We also used some macros for the bitwise ORs of configuration flags.

		</div>
		<br>

		<h3 class="subsection-header"> Hardware Details </h3>
		<div class="subsection-content">

			The hardware for the synthesizer is composed of a PIC32 microcontroller, 
			7 potentiometers, 4 buttons, an 8:1 analog multiplexer, a 12-bit DAC, 
			and a TFT display. Using user input from the various potentiometers and 
			buttons, the PIC then generates different sequences and waveforms based 
			upon the current inputs. 

			<br><br>

			A full hardware diagram can be found in the 
			<a class="external" href="#schematics">Schematics</a> 
			section.

			<br><br>

			Our TFT display is connected the way it has been for the previous labs, 
			using pins 4, 5, 6, 22, and 25. 

			<br><br>

			<!-- CONTROL FUNCTION TABLE -->
			<h3 class="diagram-label"> Button/Knob Control Functions </h3>
			<img src="images/control_uses.png" alt="controls" class="diagram-img">

			<br>

			<!-- PIN CONNECTIONS TABLE -->
			<h3 class="diagram-label"> Pin Connections </h3>
			<img src="images/pin_connex.png" alt="connections" class="diagram-img">

			<br>

			The PIC32 then used direct digital synthesis running at 100 kHz to generate 
			the correct waveform specified by the input settings. The generation of  
			the waveform required the use of an external 12-bit DAC, the MCP4822.  
			The DAC has two output pins, VoutA and VoutB, of which we only use VoutA.  
			VoutB is sent to ground, along with Vss, and the LDAC pins. 

			 <br><br>

			The DAC is responsible for the main deliverable portion of our project, 
			so its function is quite visible. However, the other main bit of 
			hardware in our setup is the CD4051B multiplexer, which takes input 
			signals from all of our potentiometers and relieves pressure on the PIC32’s 
			ADC capabilities. Most of the ADC pins on the PIC32 are taken up by the 
			TFT display, and so only four pins exist for our 7 analog inputs. 
			Clearly, even if we were to use all the ADC inputs, there would be a need 
			for multiplexing, as there would be three knobs unconnected. If we were 
			to use multiple ADC pins, then we would also have to re-configure the 
			ADC setup in order to multiplex between all the ADC pins. 

			<br><br>

			Under the hood, there exists only one ADC in the microcontroller, so it 
			would be multiplexing between all of the ADC pins, in addition to the 
			multiplexing we would be doing on each pin. The CD4051B perfectly addresses 
			this issue, due to it having eight inputs, outputting a single signal which 
			we could read on the one ADC pin on the PIC32. Thanks to the multiplexer, 
			we can keep the existing ADC configuration. Although the multiplexer requires 
			three extra channel inputs, which are controlled by the PIC32, we have plenty 
			more options with it, seeing as they can be digital outputs. The multiplexer 
			takes Vdd from the PIC32 power rail, and uses all the signal input pins except 
			for Signal 5, which we grounded. The Vss, Vee, and INH pins were also sent 
			to ground. 

			<br><br>

			In order to stabilize the voltage output by the PIC32, we placed various 10µF 
			capacitors between power and ground on the hardware. This smoothes out 
			spikes and drops in the 3.3V output of the microcontroller. 

		</div>
		<br>

		<h3 class="subsection-header"> Preexisting Code </h3>
		<div class="subsection-content">

			All of the preexisting code we used was boilerplate code from the ECE 4760
			course website for setting up ISRs, DACs, I/O pins, and timers. We also 
			used the <a class="external" href="http://dunkels.com/adam/pt/"> Protothreads 
			</a> library by Adam Dunkels, and the tft_master.c/tft_gfx.c libraries 
			provided by Professor Land.

		</div>
		<br>

		<h3 class="subsection-header"> Roadblocks </h3>
		<div class="subsection-content">

			The most vexing bottleneck in our project was getting the multiplexer to work 
			properly. After wiring it up according to the data sheet, it would only function 
			intermittently, working properly sometimes, and then being completely unresponsive 
			at others. In addition to this, when the hardware did function, a few potentiometer 
			inputs seemed to interact with others. Specifically, the first signal input would 
			be altered slightly by every other knob, and the sixth knob would bleed into all 
			other inputs. Since the multiplexer would work sporadically and unpredictably, it didn’t 
			seem as if software was the issue, though it was possible. When touching and bending 
			wires, we would occasionally be able to change the functionality of multiplexer, but 
			these events would not affect the multiplexer consistently. 

			<br><br>

			One possible explanation for 
			this behavior takes into account the electric fields our bodies generate. 
			Depending on where we would poke wires and our own orientation, the multiplexer signal 
			wires could have been affected. This issue could be exacerbated by the fact 
			that we had channel select wires crossing over the analog outputs of the multiplexer, 
			which were both in close proximity to our power rails. This served as part of 
			the motivation to move our hardware setup to perfboard. To further address 
			the signal-to-noise issue, we placed capacitors between power and ground, and moved 
			wires away from the TFT display. In case of internally broken wires, we also 
			replaced all the signal wires connecting to the multiplexer. In order to address the 
			possible internal signal bleeding of the multiplexer, we grounded pin 5 of the multiplexer,
			which equated to the 6th signal input, the multiplexer pins being 0-indexed.

			<br><br>

			After taking all the actions listed above, the multiplexer behaved more consistently, but 
			we were unable to read from more than 2 different sources, beyond which we received
			garbage data. This issue this time was a software issue; we weren’t waiting 
			long enough between switching index bits to read the ADC pin. The PIC’s <i>DigitalRead</i>
			settling time, internal ADC sampling speeds, and the multiplexer’s switching speed require 
			dozens of processor cycles of waiting, so we put in a delay of approximately a microsecond 
			before each read. The function for waiting 1µs included in the TFT library was not working
			for some reason, so this wait was achieved using a for loop with no body.

			<br><br>

			Carrying out these fixes largely took care of all the issues we were seeing. Because we 
			implemented most of these methods in parallel, we were unable to isolate 
			one particular root cause of the malfunctioning, but taken together, 
			we would say that the issues were some combination of the challenges 
			mentioned above. 

			<br><br>

			Another issue that was present throughout much of the project was the random 
			appearance of white dots on the TFT display. Over time after power-on, pixels 
			that should have stayed black would become white.The code never 
			called for white dots to be printed, so we couldn’t isolate the error. Our first 
			fix to this problem was to write a segment of the screen black every 10 seconds. 
			However, this was a purely aesthetic fix, which did not remove the underlying
			problem.

			<br><br>

			Eventually, we realized that putting our sequencer's active-step TFT updates in an ISR 
			to achieve a constant, fast update at high tempos was the root of the problem. Since
			we had TFT updates in this ISR, and in a separate thread used to update more slowly-
			updating parts of the UI, there were many scheduling scenarios in which the serial data
			sent to the TFT was corrupted. In some instances, this conflict would cause the PIC32
			to crash entirely. After realizing the origin of our problem, we moved all TFT updates
			to a single thread. This thread ran at 15-20 fps, and due to the less-frequent update,
			our sequencer's active-step readout could be jumpy at certain sequence speeds. However, 
			we gained overall performance by eliminating this potentially fatal stress on the serial
			data bus.

		</div>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- RESULTS OF PROJECt -->
	<h2 class="section-header" id="results">Results</h2>
	<div class="report-section">

		<iframe src="https://www.youtube.com/embed/-MwzoiNMvcI" class="video" frameborder="0" allowfullscreen>
		</iframe><br>

		<h3 class="subsection-header"> Wave Tables </h3>
		<div class="subsection-content">

			wave table images here

		</div>
		<br>

		<h3 class="subsection-header"> Oscilloscope Captures </h3>
		<div class="subsection-content">

			scope shots here

		</div>
		<br>

		<h3 class="subsection-header"> Speed and Responsiveness </h3>
		<div class="subsection-content">

			analysis of speed and responsiveness here

		</div>
		<br>

		<h3 class="subsection-header"> Safety </h3>
		<div class="subsection-content">

			When using this synthesizer, there aren’t any major safety considerations to 
			take into account. The greatest danger is from the user to the board itself, 
			as ESD can render the board unusable. Incorrect placement of the microcontroller on 
			the pins can also result in blowing out some of the PIC32’s pins. Of course, one must 
			take care as to not prick their fingers due to the solder points on the back of the board.

		</div>
		<br>

		<h3 class="subsection-header"> Usability </h3>
		<div class="subsection-content">

			usability considerations here

		</div>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- CONCLUSION SECTION -->
	<h2 class="section-header" id="conclusion">Conclusion</h2>
	<div class="report-section">
		<h3 class="subsection-header"> Conformity to Initial Specification </h3>
		<div class="subsection-content">

			Although our design certainly deviated somewhat from the original plan, 
			the larger direction that the final design took mirrored our original 
			vision. Below, one can see the original and final designs of our project.

			<br><br>

			<h3 class="diagram-label"> Original Project Layout/Design </h3>
			<img src="images/original-layout.png" alt="original layout" class="diagram-img">

			<br>

			<h3 class="diagram-label"> Final Project Layout/Design </h3>
			<img src="images/final-layout.png" alt="final layout" class="diagram-img">

			Some of the design changes between the intial and final designs were 
			just logistic changes, such as the two perfboards in the final product rather 
			than the initial projection of one large PCB behind a panel. The layout is 
			a more messy in our final prototype, with the knobs and buttons unlabeled
			and ungrouped. We also cut back on a few different controls, both for usability
			and because of hardware limitations. The LFO and its intensity control was
			removed entirely. The amplitude and shape envelopes were cut back from two
			knobs each, for attack and decay, to one knob each, using a modal envelope
			scheme. This change allowed for most common attack/decay parameter combinations,
			but avoided a complicated control scheme and complicated ADC configuration.

			<br><br>

			Similarly to the knobs, the buttons were not grouped by function or labeled
			in our final design. The linear/stepped interpolation button was entirely
			removed from the final design, and a table toggle button took the place of
			the table select knob. The LEDs alongside the buttons were not included in
			the final project, as the information they provided was trivial/irrelevant
			and could be derived from the TFT display. The TFT display's layout was
			essentially identical to its original conception, although the LFO frequency
			was replaced by the name of the current note to be written.

			<br><br>

			Most of the modifications we made were mostly due to lack of time and 
			resources, and given more time, we would probably structure our project 
			to visually resemble the original design. 

		</div>
		<br>

		<h3 class="subsection-header"> Future Ideas </h3>
		<div class="subsection-content">
			
			During the implementation of our project, we started realizing that there were many 
			possible expansions to this design. One of these is the length of are sequencer. 
			Playing notes, or four measures, is not too difficult to implement, fits well on the 
			TFT, and provides some flexibility in creating musical phrases. However, increasing 
			this limitation from 16 to 32 would have unlocked countless new ideas; many video 
			game and movie themes can be realized with 32 notes. In order to visualize this 
			modification on the TFT, we could halve the width of each note's representation on
			the screen, or create two pages of notes, each of which would retain the clarity of 
			the original 16-note page. Of course, a second page would add much more complexity 
			to our codebase, something we didn't want to introduce to the project's scope.

			<br><br>

			Although we could change each note's frequency individually, our wave blending 
			controls applied to the overall 16-step sequence. If we could set table index 
			and blend values for each step, our sequence would be much more dynamic. Enabling
			this kind of customation would require an extra sequencer page, which could lead
			to a much more complex control scheme and more complex code bookkeeping in our 
			TFT thread and elsewhere. 
 			
			<br><br>

 			If we were to implement these ideas, we would benefit from restructuring the layout 
 			of the TFT screen. Displaying all the new information on the current screen could 
 			get too cluttered. One way to handle all the new information we would need to display 
 			would be to have different screen templates which would be rendered depending on the
 			current 'mode' of the synthesizer. Some screen templates could be for viewing the
 			different sequencer segments, while others would be for viewing overall program
 			information such as envelope shapes, table index, and blend values. Another sequence 
 			programming feature we wanted to implement but didn't get around to was 
 			'phantom notes'. When programming steps in our current implementation, only the note
 			to be programmed is displayed. However, with 'phantom notes', a representation of
 			where the new note bar would be in the sequencer step readout would appear, adding a
 			more interactive element to note editing.
			
			<br><br>

			Another feature we would have liked to add is presets. This is the ability to save
			and later recall all parameters associated with a particular program, including its
			sequence data, into flash memory, to be recalled later even between power cycles.
			This would require another mode for the screen, as well as procedures to pack the
			program data together and save/recall it. We would also need to change the way our 
			knobs functioned, as any recalled data, with our current knob reading thread, would
			be instantly overwritten with whatever values the knobs were at. We could use one 
			of a couple different knob scaling schemes to make this work. One method would be
			a one in which, after a saved preset is loaded, internal value do not change until 
			their associated knob goes past the value stored internally. The other method would 
			be a curved method in which disagreements between knob positions and internal values 
			would be scaled on an exponential curve.

			<br><br>

			Aside from our software, one shortcoming of our project was its presentation. 
			Having exposed perf boards, hardware components, and the PIC32 looks somewhat 
			unprofessional, and also increases the possibility of the user breaking parts 
			of the project. While damage was less of an issue with us, the designers, 
			handling the hardware, if we were to create a more polished version of the synth, 
			we would fashion some sort of box to contain the whole system, possibly out of 
			laser cut acrylic or wood, with the user inputs easily accessible and labelled. 
			All pots would be bolted to the faceplate for stability, and each pot shaft would 
			have a real knob on it to allow for finer tuning of parameters. An on/off switch
			would also exist on this box. This possible improved design would be much more 
			professional and better looking as a product, and would reduce the chances of 
			accidental damage to the circuitry. 

		</div>
		<br>

		<h3 class="subsection-header"> Intellectual Property Considerations </h3>
		<div class="subsection-content">

			intellectual property considerations text...

		</div>
		<br>

		<h3 class="subsection-header"> Ethical Considerations </h3>
		<div class="subsection-content">

			This section is written in reference to the
			<a href="http://www.ieee.org/web/membership/ethics/code_ethics.html" class="external">
				IEEE Code of Ethics
			</a>.

			<br><br>

			The most important ethical issue that we faced in our project was the usage 
			of the 3rd-party software to generate our wave tables. As mentioned earlier, 
			the waveforms used in our synth sequencer were first generated using Xfer Records'
			Serum. The other programs we used were open source, and therefore free to use. 
			Using pirated software would be against the spirit of the IEEE Code of Ethics, 
			as would selling our synth using their ‘technology’. Since Ian's license of Serum
			had Xfer Records compensated and our project is not for profit, we avoid ethical 
			violations. 

			<br><br>

			In addition to stealing technology, we also could have harmed our 
			fellow students by plagiarizing their ideas. Audio-related projects are fairly 
			common, and it wouldn’t have been difficult to rip off similar ideas of our peers 
			and claim them as our own. Needless to say, this would also be a serious breach 
			of the code of ethics. Thankfully, our interest in finding our own implementation 
			rendered cheating completely unnecessary. Although we use boilerplate code from 
			the ECE 4760 page, that code was freely provided to us for use in previous labs, 
			so there exists no conflict of interest on that front. 

		</div>
		<br>

		<h3 class="subsection-header"> Legal Considerations </h3>
		<div class="subsection-content">

			legal considerations text...

		</div>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- APPENDIX A -->
	<h2 class="section-header" id="appendix-a">Appendix A</h2>
	<div class="report-section">

		The group approves this report and the YouTube video for inclusion on the course website.

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- IMPORTANT PROGRAM FILES (ANNOTATED) -->
	<h2 class="section-header" id="commented-program">Commented Program Files</h2>
	<div class="report-section">
		<ul id="code-links">
			<li><a href="code/wavetable_master.c">
				wavetable_master.c <i> (main firmware file) </i>
			</a></li>
			<li><a href="code/convert.cpp">
				convert.cpp <i> (raw 32-bit binary audio to wavetable header conversion) </i>
			</a></li>
			<li><a href="code/env_bound_accum_calcs.rb">
				env_bound_accum_calcs.rb <i> (envelope keyframe phase accumulator calculations) </i>
			</a></li>
			<li><a href="code/freq_accum_calcs.rb">
				freq_accum_calcs.rb <i> (frequency phase accumulator calculations) </i>
			</a></li>
			<li><a href="code/tempo_accum_calcs.rb">
				tempo_accum_calcs.rb <i> (tempo phase accumulator calculations) </i>
			</a></li>
		</ul>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- BUILD SCHEMATICS -->
	<h2 class="section-header" id="schematics">Schematics</h2>
	<div class="report-section">
		<!-- HARDWARE/CIRCUIT DIAGRAM -->
		<h3 class="diagram-label"> Hardware/Circuit Diagram </h3>
		<img src="images/hardware_schematic.png" alt="circuit diagram" class="diagram-img">

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- COSTS/BOM -->
	<h2 class="section-header" id="cost-details">Cost Details</h2>
	<div class="report-section">
		<b> Bill of Materials: </b>
		<br><br>

		<ul id="costs">
			<li> MicroStickII <b> ($10.00) </b> </li>
			<li> TFT LCD Display <b> ($10.00) </b> </li>
			<li> Solder Board x 2 <b> ($5.00) </b> </li>
			<li> Lab Speakers <b> ($2.00) </b> </li>
			<li> Tactile Switch x 4 <i> (Apem, Digikey Part #679-2428-ND) </i> <b> ($0.37) </b> </li>
			<li> Linear 10k Potentiometer x 7 <i> (TT Electronics/BI, Digikey Part #987-1277-ND) </i> <b> ($4.34) </b> </li>
			<li> MCP4822 12-Bit DAC <i> (Microchip Technology, Digikey Part #MCP4822-E/P-ND) </i> <b> ($3.00) </b> </li>
			<li> CD4051BE 8:1 Multiplexer <i> (Texas Instruments, Digikey Part #296-2057-5-ND) </i> <b> ($0.52) </b> </li>
		</ul>
		<br>

		<p>
			&nbsp; &nbsp;
			<b> Total cost: </b> $35.23
		</p>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- MEMBER ROLES -->
	<h2 class="section-header" id="member-roles">Member Roles</h2>
	<div class="report-section">
		<p>
			<b> Ian Hoffman </b> (ijh6)
			<br>
			<ul class="roles-list">
				<li> Software Development Lead </li>
				<li> Wavetable Creation/File Conversion </li>
				<li> Synthesis Parameter Calculation Scripting </li>
				<li> Diagramming </li>
				<li> Web Development </li>
			</ul>
		</p>
		<br>

		<p>
			<b> Joval Mathew </b> (jjm448)
			<br>
			<ul class="roles-list">
				<li> Hardware Prototyping/Design </li>
				<li> Board Layout/Soldering </li>
				<li> Software Development </li>
				<li> Project Organization and Management </li>
			</ul>
		</p>
		<br>

		<p>
			<b> Balazs Szegletes </b> (bas332)
			<br>
			<ul class="roles-list">
				<li> Hardware Prototyping/Design </li>
				<li> Board Layout/Soldering </li>
			</ul>
		</p>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>

	<!-- REFERENCES (MANUALS, ETC.) -->
	<h2 class="section-header" id="references">References</h2>
	<div class="report-section">
		<ul id="references">
			<li><a href="http://www.ti.com/lit/ds/symlink/cd4051b.pdf">
				Multiplexer Datasheet
			</a></li>
			<li><a href="http://people.ece.cornell.edu/land/courses/ece4760/labs/f2016/lab2_mcp4822.pdf"> 
				DAC Datasheet 
			</a></li>
			<li><a href="https://people.ece.cornell.edu/land/courses/ece4760/StudentWork/McNicoll/PIC32_Pinout_brl.pdf">
				PIC32 Pinout Diagram
			</a></li>
			<li><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/32bitPeripheralLibraryGuide.pdf">
				PIC32 Peripheral Libraries Guide
			</a></li>
			<li><a href="http://www.microchip.com/design-centers/32-bit">
				PIC32 Reference Manual
			</a></li>
			<li><a href="https://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_Protothreads.html">
				Protothreads on PIC32
			</a></li>
		</ul>

		<!-- LINK TO TOP OF PAGE -->
		<a href="#top" class="top-link">TOP</a>
	</div>
</body>

</html>